package kubernetes

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"regexp"

	"github.com/iancoleman/strcase"
	"github.com/turbot/steampipe-plugin-sdk/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/plugin"
	"github.com/turbot/steampipe-plugin-sdk/plugin/transform"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func tableDynamicCRD(ctx context.Context, p *plugin.Plugin) *plugin.Table {
	logger := plugin.Logger(ctx)
	logger.Trace("tableDynamicCRD")

	crd := ctx.Value("crd").(v1beta1.CustomResourceDefinition)

	reg, err := regexp.Compile("[^A-Za-z0-9]+")
	if err != nil {
		log.Fatal(err)
	}

	var tableName, description string
	var properties *map[string]v1beta1.JSONSchemaProps

	// Frame the table name from a combination of the group and crd name
	group := reg.ReplaceAllString(crd.Spec.Group, "_")
	crdName := reg.ReplaceAllString(crd.Spec.Names.Plural, "_")
	tableName = fmt.Sprintf("kubernetes_%s_%s", crdName, group)
	logger.Trace("Table Name", tableName)

	// Set the default description of the table to the table name
	description = tableName
	// If the Versions array exists and the first version has a schema defined
	// we will extract and store the list of properties for column creation
	if (len(crd.Spec.Versions) > 0) && (crd.Spec.Versions[0].Schema != nil) {
		description = crd.Spec.Versions[0].Schema.OpenAPIV3Schema.Description
		properties = &crd.Spec.Versions[0].Schema.OpenAPIV3Schema.Properties
	} else if crd.Spec.Validation != nil {
		description = crd.Spec.Validation.OpenAPIV3Schema.Description
		properties = &crd.Spec.Validation.OpenAPIV3Schema.Properties
	}

	// Add the Object meta columns
	cols := []*plugin.Column{
		{Name: "name", Type: proto.ColumnType_STRING, Transform: transform.FromField("ObjectMeta.Name"), Description: "Name of the Custom Resource Object"},
		{Name: "namespace", Type: proto.ColumnType_STRING, Transform: transform.FromField("ObjectMeta.Namespace"), Description: "Namespace to which the custom resource belongs to"},
		{Name: "uid", Type: proto.ColumnType_STRING, Transform: transform.FromField("ObjectMeta.UID"), Description: "The unique time and space value for the object generated by the server"},
		{Name: "resource_version", Type: proto.ColumnType_STRING, Transform: transform.FromField("ObjectMeta.ResourceVersion"), Description: "An opaque value that represents the internal version of the object"},
		{Name: "created", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("ObjectMeta.CreationTimestamp").Transform(transform.UnixMsToTimestamp), Description: "Create timestamp of the object"},
		{Name: "deleted", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("ObjectMeta.DeletionTimestamp").Transform(transform.UnixMsToTimestamp), Description: "Delete timestamp of the object"},
	}

	// List of columns already seen
	seenCols := map[string]bool{"name": true, "namespace": true, "uid": true, "resource_version": true, "created": true, "deleted": true}

	// Key columns for query filtering
	keyColumns := []*plugin.KeyColumn{
		{Name: "namespace", Require: plugin.Optional},
		{Name: "uid", Require: plugin.Optional},
	}

	if properties != nil {
		// If there are any results, check them for label data to build the columns
		for key, propObj := range *properties {
			// The spec object will have properties that are specific to this crd
			// we will be elevating these properties to the top level
			if key == "spec" {
				specProperties := propObj.Properties
				for specKey, specPropObj := range specProperties {
					// If we have already added the column, skip it
					if seenCols[strcase.ToSnake(specKey)] == true {
						continue
					}
					cols = append(cols, &plugin.Column{Name: strcase.ToSnake(specKey), Type: determineColumnType(specPropObj.Type), Transform: transform.FromField(fmt.Sprintf("Spec.%s", key)), Description: specPropObj.Description})
					keyColumns = append(keyColumns, &plugin.KeyColumn{Name: strcase.ToSnake(specKey), Require: plugin.Optional})
					seenCols[strcase.ToSnake(specKey)] = true
				}
			} else {
				// If we have already added the column, skip it
				if seenCols[strcase.ToSnake(key)] == true {
					continue
				}
				cols = append(cols, &plugin.Column{Name: strcase.ToSnake(key), Type: determineColumnType(propObj.Type), Transform: transform.FromField(fmt.Sprintf("Spec.%s", key)), Description: propObj.Description})
				keyColumns = append(keyColumns, &plugin.KeyColumn{Name: strcase.ToSnake(key), Require: plugin.Optional})
				seenCols[strcase.ToSnake(key)] = true
			}
		}
	}

	logger.Trace("Table Columns", cols)
	logger.Trace("Table Key Columns", keyColumns)

	return &plugin.Table{
		Name:        tableName,
		Description: description,
		List: &plugin.ListConfig{
			KeyColumns: keyColumns,
			Hydrate:    listCRDObjects,
		},
		Columns: cols,
	}
}

func listCRDObjects(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	logger := plugin.Logger(ctx)
	logger.Trace("listCRDObjects")

	crdclient, err := GetNewCrdObjectClientSet(ctx, d)
	if err != nil {
		logger.Error("kubernetes_dynamic_crd.listCRDObjects", "get_client_set_error", err)
		return nil, err
	}

	objects, err := crdclient.CRDConfigs().List(meta_v1.ListOptions{})
	obj, _ := json.Marshal(objects)
	logger.Trace("Returned Objects", string(obj))

	return nil, nil
}

func determineColumnType(colType string) proto.ColumnType {
	if colType == "string" {
		return proto.ColumnType_STRING
	} else if colType == "boolean" {
		return proto.ColumnType_BOOL
	} else if colType == "integer" {
		return proto.ColumnType_DOUBLE
	} else if colType == "number" {
		return proto.ColumnType_INT
	} else if colType == "array" || colType == "object" {
		return proto.ColumnType_JSON
	}
	return proto.ColumnType_JSON
}
